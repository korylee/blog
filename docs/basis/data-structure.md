---
title: 数据结构
date: 2020-11-11
# tags:
#   - TypeScript
# categories:
#   - frontEnd
publish: false
---

## 1. 线性表:数组、链表、栈、队列

**线性表是为了解决单线存储而存在的**。最基础结构为数组和链表，栈和堆石线性表的特殊形态，在操作上进行了限制。构造一个栈和堆结构，既可以使用数组，也可以使用链表

### 1.1 数组

就是**最简单粗暴的存储方法**。数组的快速读取其实是一个副作用，因为所有的数据都在一起，可以直接算出数据的地址。数据的优势石连续内存，可以快速读取。缺点是插入比较困难，需要向后面数据挪动位置。

> C/C++语言的数组更接近数组结构的数组概念，默认是不能动态扩容的。js 高级语言的数组概念就包含很多，比如动态扩容、语言层自实现栈、队列特性

### 1.2 链表

为了**解决可以无限增长的需求**。因为找不到一大块可以连续的存入数据，甚至不知道程序可能使用的数据总量，所以就没办法划分一块数据来使用，划小了
不够用，划大了浪费（这在早年是非常大的事情）。所以必须想办法解决问题。最后采用的方法是从入口开始，每一个数据块不仅仅有数据，还会指向下一个数据块的线索，用来寻找下一个数据。这就是链表。

```js
// js链表数据结构
let Node = function(element) {
  this.element = element;
  this.next = null;
};
```

所谓的双向链表，只是加了一个向前的线索的链表而已。不仅如此，队列、栈，都是线性表的特殊形态。进行了操作上的限制罢了。既可以是数组，又可以是链表

> 数组和链表都是一种数据结构，数组是开辟整块内存，链表则拥有 next 指针，指向下一个 node 节点

### 1.3 堆、栈/队列

`都是一种数据结构`

- 堆: 堆是一种`经过排序的树形数据结构`,每一个节点都有一个值通常我们所说的堆的数据结构，是指二叉树。堆的特点是根结点的值最小（或最大），且根节点的两个子树也是一个堆。由于堆这个特性，常用来实现优先队列。
- 栈：属于一维线性关系，`后进后出`规则。
- 队列：一维线性关系，`先进先出`原则

#### 1.3.1 堆和栈的应用

/_TODO_
NUll 等后续看看 MDN 再补
/

- 栈：最常用的就是`执行栈`，当有大函数嵌套小函数时，先逐一把所有函数压入栈中。依据后进先出，先执行最后的小函数，直到执行完最后的函数。
- 堆：在 js 等高级语言中，基本类型有`Undefined`,`Null`（特殊的）,`Boolean`,`Number`,和`String`,这些类型在内存中分别占有固定大小的空间,所以使用栈空间来保存。而`引用类型`，你根本不知道这个类型要用多大的内存空间，所以用堆内存存储最好不过。

#### 1.3.2 为什么会有栈内存和堆内存之分

通常与垃圾回收机制有关。为了使程序运行时占用的内存最小

当一个方法执行时，`每一个方法都会建立自己的内存栈`，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；

当我们在程序中`创建一个对象时，这个对象将被保存到运行时数据区`，以便于反复利用(因为对象的创建成本通常较大)，这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何应用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。

在 c 语言这类没有垃圾回收机制的语言中，定义基本类型如 char 时，系统会自动在栈上为其开辟空间，而堆是需要程序员自己申请空间，如 malloc(10)。由于栈上的空间是自动分配自动回收的，所以栈上数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放内存，就可以一直访问到，不过缺点是一旦忘记释放会造成内存泄露。

### 1.4 总结

- 数组（连续存储）
- 链表（离散存储）
  - 有序表：要求插入元素时，对元素对值进行比较，以找到相应的插入位置。
  - 顺序表、单链表、循环链表、双向链表
- 栈（线性结构常见应用，由链表或数组增减和改进功能实现），特点是先进后出
- 队列（线性结构常见应用，由链表或数组增减和改进功能实现），特点是先进先出；

数组和链表时最基础的数据结构，`相同的功能实现可以用数据结构，也可以用链表结构`，如栈和队列的实现，可以底层存储使用数组，也可以是小块内存拼接起来的链表。再比如数组的 reverse 翻转，使用数组或链表数据结构，相关算法完全不一样

## 2. 集合、字典/散列表

都属于非顺序数据结构

- `集合`：一组无序且唯一的项组成,可以理解为没有重复且没有顺序的数组(集合只存储 value)。
- `字典`：也称作映射，使用键值对的方式存储数据
  - 散列表：是实现字典的一种方式，散列算法的作用，是尽可能在数据结构中找到一个值（O(1)时间复杂度）。其中最重要的，就是选择好一个散列函数，给定一个键值，然后返回值在表中的位置

## 3. 树

树是为了解决单一入口下的非线性关联性的数据存储或排序这样的功能而存在的

- `二叉树`：二叉树的节点最多只能有两个节点(左、右节点)
  - `二叉搜索树`:二叉树的一种，左节点比父节点小，右节点比左节点大。
  - `自平衡树`（AVL）：任何一个节点左右两侧子树的高度差最多是 1
- `B树、B+树`
- `红黑树`

最常见的应用是编程时候的 map，就是利用了二叉树的可排序和可以快速插入并且保持序列完整的特性来构建键值数据对，来实现数据的插入增加以及快速查找的能力的。

## 4. 算法

![算法](https://pic1.zhimg.com/80/v2-83eb773433e690e6d416265e25fd9fc7_hd.jpg)

### 4.1 算法思想

#### 1.分治法（递归是分支的常见算法）

将原问题分解为若干个规模较小但类似于原问题的子问题（Divide），[递归]的求解这些子问题（Conquer），然后在合并这些子问题的解来建立原问题的解、

#### 2.动态规划

动态规划其实和分治策略是类似的，也是讲一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解

区分在于这些子问题会有重叠，一个字问题在求解后，可能会再次求解，于是我们想到将这些子问题的解`存储起来`，当下次再次求解这个问题时，直接拿过来就是

也就是说，动态规划所解决的问题是分治策略所解决问题的一个子集，只是这个子集更适合用动态规划来解决从而得到更小的运行时间

即用动态规划能解决的问题 分治策略肯定能解决，只是运行时间长。因此，分支策略一般用来解决子问题相互独立的问题，沉稳给标准分支，而动态规划用来解决子问题重叠的问题

#### 3.其他

- 贪心算法
- 回溯法

### 4.2 常见算法

- 排序
  - 冒泡排序
  - 快速排序
- 搜索
  - `二分法`:针对有序数组
  - `双指针法`
  - `二叉搜索树`：针对排好的二叉树。递归
- `深度优先搜索（DFS）`：优先深度，一条道走到黑。根据打印前后又分：前序、中序（中序遍历二叉查找树可得到一个关键字的有序队列）、后序
  - `递归DFS`：递归处理 left 节点，然后递归 right 节点即可
  - `栈数据结构的DFS`（空间换时间）：递归处理 left，right 节点使用栈（后进后出）保存起来，当 left 处理完再 pop 出栈顶元素作为当前 node
- `广度优先搜索（BFS）`：按照树 depth，依次搜索
  - `递归BFS`：先递归获得 depth 值，再 foreach lever 递归搜索
  - `队列数据结构的BFS`：使用队列，依次放入`当前队列第一位的left、right节点`，同时 pop 当前队列的第一位，进行删除

### 4.3 常见大 O 运行时间

- O(log,n),也叫对数时间，如：二分查找
- O(n)：线性时间，如：简单查找
- O(nlog n)如：快速查找
- O(n<sup>2</sup>)如：冒泡算法、选择排序算法，属于较慢的一种算法
- O(n!)非常慢的算法

::: tip 对数概念
log<sub>10</sub>100 等同于“将多少个 10 相乘的结果为 100”，所以 log<sub>10</sub>100=2（2 个 10 相乘等于 00）。对数运算是幂运算的逆运算，使用大 O 表示法时，log 指的是 log<sub>2</sub>,s 所以一般二分法是 log n
:::

> O(log n)比 O(n)快，当搜索的元素越多时，前者比后者快得多。

## 二分法

二分查找要求线性表 具有`随机访问的特点（例如数组）`，也要求线性表`能够根据中间元素的特点推测它两侧元素的性质`，以达到缩减问题规模的效果。针对`有序数组`，每次排除一半的选项，算法复杂度：O(log n)

给定一个 n 个元素`有序的`（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在下标，否则返回 1

```js
/**
 * @param {number[]}nums
 * @param {number} target
 * @return {number}
 */
const search = (nums, target) => {
  let left = 0,
    right = nums.length - 1;
  while (left <= right) {
    let mid = left + Math.floor((right - left) / 2);
    if (nums[mid] === target) return mid;
    if (nums[mid] > target) right = mid - 1;
    else left = mid + 1;
  }
  return -1;
};
```
